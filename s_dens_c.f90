program densidade
  
  use types
  use variables
  use funcproc

  use gmxfort_trajectory
  use gmxfort_utils
  
  !============================
  type(Trajectory) :: trj
  real :: copy(3)
  !============================
  
  call startup(outer, bin, p_grid, coord, ind, ind2, rmsd, map, ind3, &
     l_coarse, begin, end, skip, lipid, rough, slices, inside, range, &
     n_grid, bin_out, fr_in, fr_end, n_skip, n_lipid, get, div, 's_dens    ', version)

  if (.not.outer)then

     if (ind2=='miss')then

        write(*, *)
        write(*, *)'Second index file is missing'
        write(*, *)
        stop

     end if

  end if
  
  if (ind3=='miss')then

     write(*, *)
     write(*, *) 'Density index file is missing'
     write(*, *)
     stop

  end if

  !==Lendo os arquivos de index=========================
  if (.not.outer)then

     call abre_ndx(ind, in_num, n_index)
     call abre_ndx(ind2, in_num2, n_index)

  end if

  if (.not.slices) then
          
     del = 0.5
     
  end if

  !=================definindo frames para inicio e fim========                          

  call def_frame(frame, fr_in, fr_end, skip, n_skip, end, begin)

  !=================calculando o espaçamento==================    

  call def_bin(outer, bin_coarse, n_index, bin, n_grid, bin_out)

  call abre_ndx(ind3, in_dens, n_index)
  
  !==================== abrindo trajetórias =====================
  
  traj_type = coord(len(trim(coord))-2:len(trim(coord)))
  
  if (traj_type=='xtc') call trj%open(coord)
  if (traj_type=='pdb') call abre_trj(1, coord)
  
  !==================== abrindo outputs =========================
  
  if (rmsd)then

     call abre('rmsd      ', 3,'xvg', back)

     write(3, '(a7, a7)') "#SuAVE ", version
     write(3, '(a14)') '#Command Line:'
     write(3, '(a9)', advance='no') '#s_dens  '
     write(3, *) (trim(get(i)),"  ", i=1, 30)
     write(3, *) '@    title "RMSD X Frame"'
     write(3, *) '@    xaxis  label "#Frame"'
     write(3, *) '@    yaxis  label "RMSD [nm]"'

  end if
  
  if (map)then

     call abre('densmap   ', 4,'xpm', back)
     
     write(4, '(a7, a7)') "#SuAVE ", version
     write(4, *) '/* XPM */'
     write(4, *)'/* This matrix is generated by s_dens.f90 */'
     write(4, *)'/* title:   "Densmap" */'
     write(4, *)'/* x-label: "x axis [nm]" */'
     write(4, *)'/* y-label: "y axis [nm]" */'
     write(4, *)'/* type:    "Continuous" */'
     write(4, *)'static char * gv_xpm[] = {'
     write(4, *) '"',n_grid,n_grid,' 7 1",'
     
     allocate (xpm(n_grid, n_grid), stat = ierr)
     if (ierr /= 0) stop 'Not enough memory to initialize xpm matrix'
     
     allocate (r_xpm1(n_grid, n_grid), stat = ierr)
     if (ierr /= 0) stop 'Not enough memory to initialize xpm matrix'
     
     do i=1, n_grid
        
        do j=1, n_grid
           
           r_xpm1(i,j) = 0
           
        end do
        
     end do

  end if
  
  
  ! Limpando o histograma==============================
  do i=1, 1000
     
     hist(i) = 0
     
  end do
  ! histograma limpo===================================

  call system_clock (start, clock_rate, clock_max)
  
! Leitura do arquivo .gro

  ierr = 0
  a_dens = 1
  n_index = 1
  num = 1
  num2 = 1
  i_atom = 0
  x_min = 1000
  y_min = 1000
  z_min = 1000
  x_max = 0
  y_max = 0
  z_max = 0
  n_inside = 0
  tot_frame = 0
  frame = 0
  
  do while (ierr >= 0)
     
     if (traj_type=='pdb') then
        
        next_frame = .false.
 
        do while (.not.next_frame)
    
           read(1, 12, iostat=ierr) atom, buff%n_atom, buff%atom, &
                buff%resid, buff%ident, buff%n_resid, buff%code, buff%x, &
                buff%y, buff%z
           
12         format(a6, i5.1, a5, a5, a1, i4.1, a4, 3f8.3)
           
           if (ierr<0) exit
           
           if ((atom.eq.'ATOM  '))then
              
              i_atom = i_atom + 1
              
              x_max = max(x_max, buff%x)
              x_min = min(x_min, buff%x)
              y_max = max(y_max, buff%y)
              y_min = min(y_min, buff%y)
              z_max = max(z_max, buff%z)
              z_min = min(z_min, buff%z)
              
              buff%n_atom = i_atom
              
              if (outer)then
                 
                 out(i_atom) = buff
                 n_index = n_index + 1
                 
              else
                 
                 if (i_atom == in_num(num)) then
                    
                    store(num) = buff
                    n_index = n_index + 1
                    num = num + 1
                    
                 end if
                 
                 if (i_atom == in_num2(num2)) then
                    
                    store2(num2) = buff
                    n_index = n_index + 1
                    num2 = num2 + 1
                    
                 end if
                 
              end if
              
              if (i_atom == in_dens(a_dens))then
                 
                 dens(a_dens)%x = buff%x
                 dens(a_dens)%y = buff%y
                 dens(a_dens)%z = buff%z
                 
                 a_dens = a_dens + 1
                 n_index = n_index + 1
                 
              end if
              
              if(ierr > 0) then
                 
                 write(*, *)
                 write(*, *) 'Problem reading atomic position!'
                 write(*, *)
                 stop
                 
              endif
              
           end if

           next_frame = ((atom.ne.'ATOM  ').and.(n_index > 1))

        end do
        
        frame = frame + 1
        
     end if
     ! ===================================

     if (traj_type=='xtc') then

        frame = frame + trj%read_next(1)

        do while (i_atom < trj%natoms())

           i_atom  = i_atom + 1

           copy = trj%x(1, i_atom)
           x_max = max(x_max, copy(1)*10)
           x_min = min(x_min, copy(1)*10)
           y_max = max(y_max, copy(2)*10)
           y_min = min(y_min, copy(2)*10)
           z_max = max(z_max, copy(3)*10)
           z_min = min(z_min, copy(3)*10)
           
           if (i_atom == in_num(num)) then

              store(num)%x = copy(1)*10
              store(num)%y = copy(2)*10
              store(num)%z = copy(3)*10
              n_index = n_index + 1
              num = num + 1

           end if

           if (i_atom == in_num2(num2)) then

              store2(num2)%x = copy(1)*10
              store2(num2)%y = copy(2)*10
              store2(num2)%z = copy(3)*10
              n_index = n_index + 1
              num2 = num2 + 1

           end if

           if (i_atom == in_dens(a_dens))then
              
              dens(a_dens)%x = copy(1)*10
              dens(a_dens)%y = copy(2)*10
              dens(a_dens)%z = copy(3)*10
              a_dens = a_dens + 1
              n_index = n_index + 1
              
           end if
           
        end do

     end if
     ! ===================================

     ! Fitting process =============================================================
     
     eval_skip = ((mod((frame-fr_in),(n_skip+1))==0))
     
     if ((frame>fr_in-1).and.(frame<fr_end+1).and.(eval_skip).and.(ierr>=0)) then
        
        tot_frame = tot_frame + 1 ! para programas que calculam propriedades medias
              
        noi1 = num - 1
        noi2 = num2 - 1
        
        if (l_coarse) then
           
           !
           ! Estruturação do primeiro coarse grid
           
           dx = (x_max - x_min)/bin_coarse
           dy = (y_max - y_min)/bin_coarse
           
           !obtendo parametros
           
           call param(x_max, x_min, y_max, y_min, num, r_fit, al, rough)
           
           !$OMP parallel do private(s_grid, dist, peso, k, aux, j)
           do i=1, bin_coarse + 1
              
              do j=1, bin_coarse + 1
                 
                 aux = (i-1)*(bin_coarse + 1) + j
                 coarse(aux)%x = (i-1)*dx + x_min
                 coarse(aux)%y = (j-1)*dy + y_min
                 
                 s_grid = 0
                 coarse(aux)%z = 0
                 
                 do k=1, num - 1
                    
                    dist = (coarse(aux)%x - store(k)%x)**2
                    dist = dist + (coarse(aux)%y - store(k)%y)**2
                    
                    if (dist<r_fit*r_fit)then
                       
                       peso = exp(-(dist*al*al/pi))
                       s_grid = s_grid + peso
                       coarse(aux)%z = coarse(aux)%z + peso*store(k)%z
                       
                    end if
                    
                 end do
                 
                 coarse(aux)%z = coarse(aux)%z/s_grid
                 
              end do
              
           end do
           !$OMP end parallel do
           
           num = (bin_coarse + 1)**2 + 1
           
           ! Fim da estruturação 1
           
           ! Estruturação do segundo coarse grid
           
           call param(x_max, x_min, y_max, y_min, num2, r_fit, al, rough)
           
           !$OMP parallel do private(s_grid, dist, peso, k, aux, j)
           do i=1, bin_coarse + 1
              
              do j=1, bin_coarse + 1
                 
                 aux = (i-1)*(bin_coarse + 1) + j
                 coarse2(aux)%x = (i-1)*dx + x_min
                 coarse2(aux)%y = (j-1)*dy + y_min
                 
                 s_grid = 0
                 coarse2(aux)%z = 0
                 
                 do k=1, num2 - 1
                    
                    dist = (coarse2(aux)%x - store2(k)%x)**2
                    dist = dist + (coarse2(aux)%y - store2(k)%y)**2
                    
                    if (dist<r_fit*r_fit)then
                       
                       peso = exp(-(dist*al*al/pi))
                       coarse2(aux)%z = coarse2(aux)%z + peso*store2(k)%z
                       s_grid = s_grid + peso
                       
                    end if
                    
                 end do
                 
                 coarse2(aux)%z = coarse2(aux)%z/s_grid
                 
              end do
              
           end do
           !$OMP end parallel do
           
           num2 = (bin_coarse + 1)**2 + 1
           
        else
           
           coarse = store
           coarse2 = store2
           
        end if
        
        !estruturação do primeiro grid de alta resolução
        dx = (x_max - x_min)/n_grid
        dy = (y_max - y_min)/n_grid
        
        call param(x_max, x_min, y_max, y_min, num, r_fit, al, rough)
        
        !$OMP parallel do private(s_grid, dist, peso, k, j)
        do i=1, n_grid+1
           
           do j=1, n_grid+1
              
              grid(i,j)%x = (i-1)*dx + x_min
              grid(i,j)%y = (j-1)*dy + y_min
              
              s_grid = 0
              grid(i,j)%z = 0
              
              do k=1, num - 1
                 
                 dist = (grid(i,j)%x - coarse(k)%x)**2
                 dist =  dist + (grid(i,j)%y - coarse(k)%y)**2
                 
                 if (dist<r_fit*r_fit)then
                    
                    peso = exp(-(dist*al*al/pi))
                    s_grid = s_grid + peso
                    grid(i,j)%z = grid(i,j)%z + peso*coarse(k)%z
                    
                 end if
                 
              end do
              
              grid(i,j)%z = grid(i,j)%z/s_grid
              
           end do
           
        end do
        !$OMP end parallel do 
        
        ! estruturação do segundo grid de alta resolução
        
        call param(x_max, x_min, y_max, y_min, num2, r_fit, al, rough)
        
        !$OMP parallel do private(s_grid, dist, peso, k, j)              
        do i=1, n_grid+1
           
           do j=1, n_grid+1
              
              grid2(i,j)%x = (i-1)*dx + x_min
              grid2(i,j)%y = (j-1)*dy + y_min
              
              s_grid = 0
              grid2(i,j)%z = 0
              
              do k=1, num2 - 1
                 
                 dist = (grid2(i,j)%x - coarse2(k)%x)**2
                 dist = dist + (grid2(i,j)%y - coarse2(k)%y)**2
                 
                 if (dist<r_fit*r_fit) then
                    
                    peso = exp(-(dist*al*al/pi))
                    s_grid = s_grid + peso
                    grid2(i,j)%z = grid2(i,j)%z + peso*coarse2(k)%z
                    
                 end if
                 
              end do
              
              grid2(i,j)%z = grid2(i,j)%z/s_grid
              
           end do
           
        end do
        !$OMP end parallel do 
        
        !Contrução do grid médio para cálculo de densidade
        
        !$OMP parallel do private(j)
        do i=1, n_grid+1
           
           do j=1, n_grid+1
              
              grid3(i,j)%x = grid(i,j)%x
              grid3(i,j)%y = grid(i,j)%y
              grid3(i,j)%z = (grid(i,j)%z + grid2(i,j)%z)/2 
              
           end do
           
        end do
        !$OMP end parallel do 
        
        ! Fim do cálculo

        if ((slices).and.(frame==1)) then
           
           del = (z_max - z_min)/div
           
        else
           
           if (frame==1) then
              
              div = nint((z_max - z_min)/del)
              
           end if
           
        end if
        
        ! distribuição das moléculas do espaço no plano
        ! 'a' contem os atomos entre (a-1)*dx-dx/2 e (a-1)*dx+dx/2
        !
        
        do i=1, a_dens-1
           
           a = nint((dens(i)%x-x_min)/dx) + 1
           b = nint((dens(i)%y-y_min)/dy) + 1
           dist_z = dens(i)%z-grid3(a,b)%z
           
           if (map) then
              
              r_xpm1(a,b) = r_xpm1(a,b) + 1
              
           end if
           
           bini = nint(dist_z/del + 500)
           
           hist(bini) = hist(bini) + 1*1000/(del*(x_max-x_min)*(y_max-y_min))
           
           if (inside)then
              
              if ((dens(i)%z - grid(a,b)%z)*(dens(i)%z - grid2(a,b)%z)<=0) then
                 
                 n_inside = n_inside + 1
                 
              end if
              
           end if
           
        end do
        
        if (rmsd)then
           
           write(3, *) calc_rmsd(store, store2, grid, grid2, x_min, y_min, dx, dy, noi1, noi2)/10
           
        end if
        
        ! fim da distribuição
        
     end if !======((frame<fr_in-1).and.(frame>fr_end+1))
     
     tot_dens = a_dens
     gz = z_max-z_min
     n_index = 1
     i_atom = 0
     num = 1
     num2 = 1
     a_dens = 1
     x_min = 1000
     y_min = 1000
     z_min = 1000
     x_max = 0
     y_max = 0
     z_max = 0
     
     !====garante que fr_end sempre seja maior que frame ===
     !====caso essa variável não tenha sido fixada==========
     if (.not.end)then
        
        fr_end = frame + 1
        
     end if
     !======================================================

     if ((frame>=trj%NFRAMES).and.(traj_type=='xtc')) ierr = -1 ! apenas quando lendo o tipo XTC

  end do

  ! Fim da leitura do arquivo .pdb

  if (traj_type=='xtc') call trj%close()
  if (traj_type=='pdb') close(1)
  
  if (rmsd)then
     
     close(3)
     
  end if

  call system_clock (finish, clock_rate, clock_max)
  
  ! cálculo da densidade pelo eixo z=====================
  
  call abre('density   ', 5,'xvg', back)
  
  write(5, '(a7, a7)') "#SuAVE ", version
  write(5, '(a14)') '#Command Line:'
  write(5, '(a9)', advance='no') '#s_dens  '
  write(5, *) (trim(get(i)),"  ", i=1, 30)
  write(5, *) '@    title "System Density"'
  write(5, *) '@    xaxis  label "Distance from grid [nm]"'
  write(5, *) '@    yaxis  label "Density [nm\S-3\N]"'

  do i=500-div, 500+div
     
     write(5, *) ((i-500)*del)/10, hist(i)/tot_frame
     
  end do
  ! fim do cálculo  ==========================
  
  close(5)
  
  if (p_grid)then
     
     call print_grid(grid, n_grid+1, n_grid+1, 'grid1', back)
     call print_grid(grid2, n_grid+1, n_grid+1, 'grid2', back)
     call print_grid(grid3, n_grid+1, n_grid+1, 'grid3', back)    
     
  end if
  
  if (map) then

     ! escrita do arquivo XPM

     minv = 1000
     maxv = 0

     do i=1, n_grid

        do j=1, n_grid

           r_xpm1(i,j) = 1000*r_xpm1(i,j)/(tot_frame*dx*dy*gz)

           if (r_xpm1(i,j)>maxv)then
              maxv = r_xpm1(i,j)
           end if

           if (r_xpm1(i,j)<minv)then
              minv = r_xpm1(i,j)
           end if

        end do

     end do

     del = (maxv - minv)/6

     call print_xpm(n_grid, del, dx, dy, gx, gy, xpm, r_xpm1, minv, 'b')

     close(4)
     
  end if

  if (inside)then
     
     write(*, *)
     write(*, '(a39, f6.1)') " Selected atoms inside the structure = ", n_inside/tot_frame
     write(*, 2) " Percentage of atoms inside  = ", n_inside*100/tot_frame/tot_dens, " %"
     write(*, 2) " Percentage of atoms outside = ", (1-n_inside/tot_frame/tot_dens)*100, " %"
2    format(a31, f4.1, a2)
     
  end if
  
  call ending(back, finish, start, clock_rate) ! Finaliza programa e mostra tempo de processamento
  
end program densidade
